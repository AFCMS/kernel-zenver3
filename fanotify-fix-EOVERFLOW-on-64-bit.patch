Bugzilla: 696821
Upstream-status: Sent http://marc.info/?l=linux-kernel&m=139835974112096&w=2

On 64-bit systems, O_LARGEFILE is automatically added to flags inside
the open() syscall (also openat(), blkdev_open(), etc).
Userspace therefore defines O_LARGEFILE to be 0 - you can use it,
but it's a no-op. Everything should be O_LARGEFILE by default.

But: when fanotify does create_fd() it uses dentry_open(), which skips
all that. And userspace can't set O_LARGEFILE in fanotify_init() because
it's defined to 0. So if fanotify gets an event regarding a large file,
the read() will just fail with -EOVERFLOW.

This patch adds O_LARGEFILE to fanotify_init()'s event_f_flags on 64-bit
systems, using the same test as open()/openat()/etc.

Resolves: https://bugzilla.redhat.com/show_bug.cgi?id=696821

Acked-by: Eric Paris <eparis@redhat.com>
Signed-off-by: Will Woods <wwoods@redhat.com>
---
 fs/notify/fanotify/fanotify_user.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/fs/notify/fanotify/fanotify_user.c b/fs/notify/fanotify/fanotify_user.c
index 4e565c8..732648b 100644
--- a/fs/notify/fanotify/fanotify_user.c
+++ b/fs/notify/fanotify/fanotify_user.c
@@ -698,6 +698,8 @@ SYSCALL_DEFINE2(fanotify_init, unsigned int, flags, unsigned int, event_f_flags)
 	}
 	group->overflow_event = &oevent->fse;
 
+	if (force_o_largefile())
+		event_f_flags |= O_LARGEFILE;
 	group->fanotify_data.f_flags = event_f_flags;
 #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
 	spin_lock_init(&group->fanotify_data.access_lock);
-- 
1.9.0
